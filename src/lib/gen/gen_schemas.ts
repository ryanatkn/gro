import {
	compile,
	type Options as JsonSchemaToTypeScriptOptions,
} from '@ryanatkn/json-schema-to-typescript';
import {stripEnd} from '@feltjs/util/string.js';
import {traverse} from '@feltjs/util/object.js';

import type {GenContext, RawGenResult} from './gen.js';
import {
	GEN_SCHEMA_IDENTIFIER_SUFFIX,
	type GenModuleMeta,
	type SchemaGenModule,
} from './gen_module.js';
import {normalize_type_imports} from './type_imports.js';
import {infer_schema_types, is_json_schema, type JsonSchema} from '../util/schema.js';
import {to_root_path} from '../util/paths.js';

export const gen_schemas = async (
	mod: SchemaGenModule,
	ctx: GenContext,
	options: Partial<JsonSchemaToTypeScriptOptions>,
): Promise<RawGenResult> => {
	const {imports, types} = await run_schema_gen(ctx, mod, options);
	const origin_root_path = to_root_path(ctx.origin_id);
	return `
		// generated by ${origin_root_path}

		${imports.join('\n;\n')}
		
    ${types.join(';\n\n')}

		// generated by ${origin_root_path}
	`;
};

const run_schema_gen = async (
	ctx: GenContext,
	mod: SchemaGenModule,
	options: Partial<JsonSchemaToTypeScriptOptions>,
): Promise<{imports: string[]; types: string[]}> => {
	const raw_imports: string[] = [];
	const types: string[] = [];

	for (const {identifier, schema: original_schema} of to_schema_info_from_module(mod)) {
		infer_schema_types(original_schema, ctx); // process the schema, adding inferred data
		// `json-schema-to-typescript` mutates the schema, so clone first
		const schema = structuredClone(original_schema);

		// Compile the schema to TypeScript.
		const final_identifier = stripEnd(identifier, GEN_SCHEMA_IDENTIFIER_SUFFIX); // convenient to avoid name collisions
		// eslint-disable-next-line no-await-in-loop
		const result = await compile(schema, final_identifier, {
			bannerComment: '',
			format: false,
			...options,
		});
		types.push(result);

		// Walk the original schema and add any imports with `tsImport`.
		// We don't walk `schema` because we don't include the types of expanded schema references.
		// TODO is this still true after the tsType/tsImport inference?
		traverse(original_schema, (key, v) => {
			if (key === 'tsImport') {
				if (typeof v === 'string') {
					raw_imports.push(v);
				} else if (Array.isArray(v)) {
					raw_imports.push(...v);
				}
			}
		});
	}

	const imports = await normalize_type_imports(raw_imports, ctx.origin_id);

	return {imports, types};
};

export const to_schemas_from_modules = (gen_modules: GenModuleMeta[]): JsonSchema[] => {
	const schemas: JsonSchema[] = [];
	for (const gen_module of gen_modules) {
		if (gen_module.type !== 'schema') continue;
		for (const schema_info of to_schema_info_from_module(gen_module.mod)) {
			schemas.push(schema_info.schema);
		}
	}
	return schemas;
};

const to_schema_info_from_module = (
	mod: SchemaGenModule,
): Array<{identifier: string; schema: JsonSchema}> => {
	const schema_info: Array<{identifier: string; schema: JsonSchema}> = [];
	for (const identifier in mod) {
		const value = mod[identifier];
		if (is_json_schema(value)) schema_info.push({identifier, schema: value});
	}
	return schema_info;
};
