import {type Gen} from '../lib/gen.ts';
import {basename} from 'node:path';

// Example gen file demonstrating how to use the Filer to analyze project structure
export const gen: Gen = async ({filer, log}) => {
	log.info('Generating project statistics using Filer...');

	// Initialize the filer to access the file graph
	await filer.init();

	// Basic validation that it works
	if (!filer.inited) {
		throw new Error('Filer should be initialized after calling init()');
	}
	if (filer.files.size === 0) {
		throw new Error('No files found in project');
	}

	// Analyze project structure
	const stats = {
		total_files: filer.files.size,
		by_extension: new Map<string, number>(),
		largest_files: [] as Array<{id: string; size: number}>,
		most_dependencies: [] as Array<{id: string; dep_count: number}>,
		external_deps: new Set<string>(),
	};

	// Gather statistics
	for (const disknode of filer.files.values()) {
		// Count by extension
		const ext = disknode.id.substring(disknode.id.lastIndexOf('.'));
		stats.by_extension.set(ext, (stats.by_extension.get(ext) || 0) + 1);

		// Track files with most dependencies
		if (disknode.dependencies.size > 0) {
			stats.most_dependencies.push({
				id: disknode.id,
				dep_count: disknode.dependencies.size,
			});
		}

		// Track external dependencies
		for (const dep of disknode.dependencies.values()) {
			if (dep.external) {
				stats.external_deps.add(dep.id);
			}
		}

		// Track file sizes (by content length as proxy)
		if (disknode.contents) {
			stats.largest_files.push({
				id: disknode.id,
				size: disknode.contents.length,
			});
		}
	}

	// Helper function for stable sorting with secondary sort by name
	const sort_by_count_then_name = <T>(
		items: T[],
		get_count: (item: T) => number,
		get_name: (item: T) => string,
	) => {
		return items.sort((a, b) => {
			const count_diff = get_count(b) - get_count(a);
			if (count_diff !== 0) return count_diff;
			return get_name(a).localeCompare(get_name(b));
		});
	};

	// Sort and limit results with stable sorting
	stats.most_dependencies = sort_by_count_then_name(
		stats.most_dependencies,
		(f) => f.dep_count,
		(f) => f.id,
	).slice(0, 5);

	stats.largest_files = sort_by_count_then_name(
		stats.largest_files,
		(f) => f.size,
		(f) => f.id,
	).slice(0, 5);

	// Format extension stats with stable sorting
	const ext_entries = sort_by_count_then_name(
		Array.from(stats.by_extension.entries()),
		([_ext, count]) => count,
		([ext, _count]) => ext,
	).slice(0, 10);

	log.info(`Analyzed ${stats.total_files} files`);

	// Generate markdown report
	return `# Project File Statistics

Generated by analyzing the in-memory file graph with Filer.

## Overview
- **Total files**: ${stats.total_files}
- **External dependencies**: ${stats.external_deps.size}

## Files by extension (top 10)
${ext_entries.map(([ext, count]) => `- \`${ext}\`: ${count} files`).join('\n')}

## Files with most dependencies (top 5)
${
	stats.most_dependencies
		.map((f) => `- \`${basename(f.id)}\`: ${f.dep_count} dependencies`)
		.join('\n') || '- No files with dependencies found'
}

## Largest files by content (top 5)
${
	stats.largest_files
		.map((f) => `- \`${basename(f.id)}\`: ${(f.size / 1024).toFixed(1)} KB`)
		.join('\n') || '- No file contents available'
}

---

This demonstrates using \`filer.init()\` in gen files to analyze project structure without file system access.
`;
};
