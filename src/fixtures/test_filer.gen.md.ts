import {type Gen} from '../lib/gen.ts';
import {basename} from 'node:path';

// Example gen file demonstrating how to use the Filer to analyze project structure
export const gen: Gen = async ({filer, log}) => {
	log.info('Generating project statistics using Filer...');

	// Initialize the filer to access the file graph
	await filer.init();

	// Basic validation that it works
	if (!filer.inited) {
		throw new Error('Filer should be initialized after calling init()');
	}
	if (filer.files.size === 0) {
		throw new Error('No files found in project');
	}

	// Analyze project structure
	const stats = {
		total_files: 0, // Will count only non-external files
		by_extension: new Map<string, number>(),
		largest_files: [] as Array<{id: string; size: number}>,
		most_dependencies: [] as Array<{id: string; dep_count: number}>,
		ts_files: new Set<string>(), // DEBUG: Track all .ts files
	};

	// DEBUG: Log filer state
	log.info(`Total files in filer: ${filer.files.size}`);
	let external_count = 0;
	for (const disknode of filer.files.values()) {
		if (disknode.external) external_count++;
	}
	log.info(`External files: ${external_count}, Non-external files: ${filer.files.size - external_count}`);

	// Gather statistics
	for (const disknode of filer.files.values()) {
		// Skip external files for all statistics
		if (disknode.external) {
			continue;
		}

		// Count non-external files
		stats.total_files++;

		// Count by extension (only for files that have extensions)
		const dot_index = disknode.id.lastIndexOf('.');
		if (dot_index !== -1 && dot_index < disknode.id.length - 1) {
			const ext = disknode.id.substring(dot_index);
			stats.by_extension.set(ext, (stats.by_extension.get(ext) || 0) + 1);

			// DEBUG: Track .ts files specifically
			if (ext === '.ts') {
				if (stats.ts_files.has(disknode.id)) {
					log.warn(`DUPLICATE .ts file found: ${disknode.id}`);
				}
				stats.ts_files.add(disknode.id);
				log.info(`Adding .ts file: ${disknode.id}`);
			}
		}

		// Track files with most dependencies
		if (disknode.dependencies.size > 0) {
			stats.most_dependencies.push({
				id: disknode.id,
				dep_count: disknode.dependencies.size,
			});
		}

		// Track file sizes (by content length as proxy)
		if (disknode.contents) {
			stats.largest_files.push({
				id: disknode.id,
				size: disknode.contents.length,
			});
		}
	}

	// Helper function for stable sorting with secondary sort by name
	const sort_by_count_then_name = <T>(
		items: Array<T>,
		get_count: (item: T) => number,
		get_name: (item: T) => string,
	) => {
		return items.sort((a, b) => {
			const count_diff = get_count(b) - get_count(a);
			if (count_diff !== 0) return count_diff;
			return get_name(a).localeCompare(get_name(b));
		});
	};

	// Sort and limit results with stable sorting
	stats.most_dependencies = sort_by_count_then_name(
		stats.most_dependencies,
		(f) => f.dep_count,
		(f) => f.id,
	).slice(0, 5);

	stats.largest_files = sort_by_count_then_name(
		stats.largest_files,
		(f) => f.size,
		(f) => f.id,
	).slice(0, 5);

	// Format extension stats with stable sorting
	const ext_entries = sort_by_count_then_name(
		Array.from(stats.by_extension.entries()),
		([_ext, count]) => count,
		([ext, _count]) => ext,
	).slice(0, 10);

	log.info(`Analyzed ${stats.total_files} files`);
	log.info(`Found ${stats.ts_files.size} .ts files`);

	// Sort TypeScript files for consistent output
	const sorted_ts_files = Array.from(stats.ts_files).sort();

	// Generate markdown report
	return `# Project File Statistics

Generated by analyzing the in-memory file graph with Filer.

## Overview
- **Total files**: ${stats.total_files}

## DEBUG: TypeScript Files (${stats.ts_files.size} total)
${sorted_ts_files.map(file => `- \`${file}\``).join('\n')}

## Files by extension (top 10)
${ext_entries.map(([ext, count]) => `- \`${ext}\`: ${count} files`).join('\n')}

## Files with most dependencies (top 5)
${
	stats.most_dependencies
		.map((f) => `- \`${basename(f.id)}\`: ${f.dep_count} dependencies`)
		.join('\n') || '- No files with dependencies found'
}

## Largest files by content (top 5)
${
	stats.largest_files
		.map((f) => `- \`${basename(f.id)}\`: ${(f.size / 1024).toFixed(1)} KB`)
		.join('\n') || '- No file contents available'
}

---

This demonstrates using \`filer.init()\` in gen files to analyze project structure without file system access.
`;
};
